(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{"./docs/rehydrators/using-rehydratechildren.mdx":function(e,n,a){"use strict";a.r(n);var t=a("./node_modules/react/index.js"),r=a.n(t),o=a("./node_modules/@mdx-js/tag/dist/index.js");function m(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}n.default=function(e){var n=e.components;m(e,["components"]);return r.a.createElement(o.MDXTag,{name:"wrapper",components:n},r.a.createElement(o.MDXTag,{name:"h1",components:n,props:{id:"using-rehydratechildren"}},"Using rehydrateChildren"),r.a.createElement(o.MDXTag,{name:"blockquote",components:n},r.a.createElement(o.MDXTag,{name:"p",components:n,parentName:"blockquote"},"A working version of this can be seen in the ",r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"/demo/ShowMore"}},r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"a"},"ShowMore")," demo"))),r.a.createElement(o.MDXTag,{name:"p",components:n},"Let's take ",r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"/rehydrators/simple"}},"our ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"a"},"ShowMore")," component"),", and enhance it."),r.a.createElement(o.MDXTag,{name:"p",components:n},"Instead of hiding or showing a ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"content")," string, we want to hide or show some ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"children"),", which can be arbitrary React elements. To accomplish this, we can use the ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"rehydrateChildren")," function, which is always passed as the second argument to a rehydrator."),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"rehydrateChildren")," accepts a DOM node as its only argument, and - importantly - will return its ",r.a.createElement(o.MDXTag,{name:"em",components:n,parentName:"p"},"children")," as React elements. Passing in ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<div><p>Hello, world!</p></div>"),", for example, will only return ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<p>Hello, world!</p>"),"."),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"rehydrateChildren")," returns a ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Promise")," - this is important to accomodate code splitting. You should always ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"await")," it, or use ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".then()"),"."),r.a.createElement(o.MDXTag,{name:"p",components:n},"The rehydrator should look like this:"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},'import ShowMore from "./ShowMore";\n\nexport default async (domNode, rehydrateChildren) => {\n  const children = await rehydrateChildren(\n    domNode.querySelector(".ShowMore-children")\n  );\n\n  return <ShowMore>{children}</ShowMore>;\n};\n')),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"rehydratechildren-and-reactfragment"}},r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"h2"},"rehydrateChildren")," and ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"h2"},"React.Fragment")),r.a.createElement(o.MDXTag,{name:"p",components:n},"If a component contains more than one child, then ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"rehydrateChildren")," will return a ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"React.Fragment"),". This may affect your components if you use ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"React.Children"),", in order to iterate over child components from a parent component."),r.a.createElement(o.MDXTag,{name:"p",components:n},"To overcome this, you have two options:"),r.a.createElement(o.MDXTag,{name:"ol",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ol"},r.a.createElement(o.MDXTag,{name:"p",components:n,parentName:"li"},"In your rehydrator function, you can check the type of the children you get back. If it's a ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"React.Fragment"),", you can pass through its children. This isn't generally recommended, but it will work in a pinch."),r.a.createElement(o.MDXTag,{name:"pre",components:n,parentName:"li"},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},'(domNode, rehydrateChildren) => {\n  const children = await rehydrateChildren(domNode.querySelector(".MyComponent-children"));\n\n  if (children.type === React.Fragment) {\n    return <MyComponent>{children.props.children}</MyComponent>;\n  }\n\n  return <MyComponent>{children}</MyComponent>\n}\n'))),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ol"},r.a.createElement(o.MDXTag,{name:"p",components:n,parentName:"li"},"Unwrap ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"React.Fragment")," while you iterate over children. This has the added advantage of making your component work with fragments, rather than patching support into the rehydrator."),r.a.createElement(o.MDXTag,{name:"pre",components:n,parentName:"li"},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"const getTitles = children => {\n  const titles = [];\n\n  React.Children.forEach(children, child => {\n    if (child.type === React.Fragment) {\n      // Recursively unwrap `React.Fragment`'s children, get their titles,\n      // and add them to the return value.\n      titles.push(...getTitles(child.props.children));\n    } else if (child.type === MySubcomponent) {\n      // For a specific component type, extract the title prop.\n      titles.push(child.props.title);\n    }\n  });\n\n  return titles;\n};\n")),r.a.createElement(o.MDXTag,{name:"p",components:n,parentName:"li"},"You could extend this to ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"cloneElement"),", as well."),r.a.createElement(o.MDXTag,{name:"pre",components:n,parentName:"li"},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"const getTitles = children => {\n  const titles = [];\n\n  const mapCallback = child => {\n    if (child.type === React.Fragment) {\n      return (\n        <React.Fragment>\n          {React.Children.map(child.props.children, mapCallback)}\n        </React.Fragment>\n      );\n    }\n\n    if (child.type === MySubcomponent) {\n      return React.cloneElement(\n        child,\n        { date: new Date() },\n        child.props.children\n      );\n    }\n\n    return child;\n  };\n\n  return React.Children.map(children, mapCallback);\n};\n")))))}}}]);